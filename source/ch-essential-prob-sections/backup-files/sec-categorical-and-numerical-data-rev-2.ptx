<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="sec-Numerical-and-Categorical-Data" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Numerical and Categorical Data</title>
  <introduction>
    <p>
      When analyzing data, it is essential to understand the type of data you are working with and how to safely convert it into a numerical representation for processing by machine learning models. There are three fundamental data types:
      <ol>
        <li>
          <p>
            <term>Categorical Data</term>: Data that represents discrete groups or labels with no inherent order.
          </p>
        </li>
        <li>
          <p>
            <term>Ordinal Data</term>: A type of categorical data with a defined, meaningful order.
          </p>
        </li>
        <li>
          <p>
            <term>Numerical Data</term>: Data that represents quantities and can be measured and compared numerically.
          </p>
        </li>
      </ol>
    </p>
  </introduction>
  <subsection xml:id="subsec-Categorical-Data">
    <title>Categorical Data</title>
    <p>
      <term>Categorical Data</term> represents discrete groups or labels with no inherent order between the values. For example, a variable named 'Color' can take values from the set {"red", "blue", "green"}. Another variable may be 'Animal' with values from the set {"cat", "dog", "parrot"}. In Python's Pandas library, you can store this as an <c>object</c> type or, for efficiency and clarity, convert it to a <c>category</c> type.
    </p>
    <p>
    To represent categorical data, you can use the Pandas library. For instance:
    </p>
    <program language="python" line-numbers="yes">
        <code>
        import pandas as pd
        colors = pd.Series(["red", "blue", "red", "green"], dtype="category")
        print(colors)
        </code>
    </program>
    <p>
    This code produces the following output:
    </p>
    <pre>
    0      red
    1     blue
    2      red
    3    green
    dtype: category
    Categories (3, object): ['blue', 'green', 'red']
    </pre>
    <p>
      Many machine learning (ML) algorithms require a numerical representation of these symbolic or qualitative values. A very popular method for this is <term>one-hot encoding</term>.
    </p>
    <p>
      <term>One-Hot Encoding</term>: To get a one-hot representation of a categorical variable, suppose there are <c>C</c> different values. For the 'Color' variable above, we have <c>C=3</c> unique values. We represent each value with a <c>C</c>-dimensional vector with a '1' at only one position and '0' at all other positions. For example, for the unique colors:
      <me>
        \text{"red"} = [1, 0, 0], \ \text{"blue"} = [0, 1, 0], \  \text{"green"} = [0, 0, 1].
      </me>
      The complete one-hot encoded matrix for the <c>colors</c> series would look like presented in Table <xref ref="tab-one-hot-encoding-color"/>.
    </p>
 

    <table xml:id="tab-one-hot-encoding-color">
        <title>Example of One-Hot Encoding</title>

        <tabular>
            <row>
                <cell></cell>
                <cell>Sample 1</cell>
                <cell>Sample 2</cell>
                <cell>Sample 3</cell>
                <cell>Sample 4</cell>
            </row>
            <row>
                <cell header="yes">Original Data</cell>
                <cell>red</cell>
                <cell>blue</cell>
                <cell>red</cell>
                <cell>green</cell>
            </row>
            <row>
                <cell header="yes">Color_red</cell>
                <cell>1</cell>
                <cell>0</cell>
                <cell>1</cell>
                <cell>0</cell>
            </row>
            <row>
                <cell header="yes">Color_blue</cell>
                <cell>0</cell>
                <cell>1</cell>
                <cell>0</cell>
                <cell>0</cell>
            </row>
            <row>
                <cell header="yes">Color_green</cell>
                <cell>0</cell>
                <cell>0</cell>
                <cell>0</cell>
                <cell>1</cell>
            </row>
        </tabular>
 
    </table>
    <p>
      The primary limitation of one-hot encoding is that the resulting vector dimension is equal to the number of unique categories (<c>C</c>). If <c>C</c> becomes very large, such as with words in a language, this can be computationally inefficient. In such cases, it is often better to represent each value by a more dense <term>embedding</term>, which we will explore in a later section.
    </p>
  </subsection>
  
  <subsection xml:id="subsec-Ordinal-Data">
    <title>Ordinal Data</title>
    <p>
      <term>Ordinal Data</term> is a type of categorical data with a defined order. For example, a variable for clothing size may have the order "small" &lt; "medium" &lt; "large", or a satisfaction rating may be "low" &lt; "medium" &lt; "high". The order matters, but the numerical difference between categories is not necessarily meaningful. You can define an ordered category in Pandas as follows.
    </p>
    <program language="python" line-numbers="yes">
        <code>
        sizes = pd.Series(["medium", "small", "large", "small"], 
            dtype=pd.CategoricalDtype(categories=["small", "medium", "large"], ordered=True))
        print(sizes)
        </code>
    </program>
    <p>
    This code produces the following output, which shows the defined order of the categories:
    </p>
    <pre>
    0    medium
    1     small
    2     large
    3     small
    dtype: category
    Categories (3, object): ['small' &lt; 'medium' &lt; 'large']
    </pre>
    <p>
      For analysis in machine learning, ordinal values must be mapped to integers. However, if you perform this mapping naively, you can mislead the algorithm into learning something incorrect about your data. For instance, suppose you have a variable called "Education_Level" with the order: High School &lt; Bachelor's &lt; Master's &lt; PhD. If you naively map High School $\rightarrow$ 1, Bachelor's $\rightarrow$ 2, Master's $\rightarrow$ 3, PhD $\rightarrow$ 4, you are incorrectly implying that the difference between these levels is a constant '1' for all of them. In reality, the step from a Bachelor's to a Master's degree is not quantitatively equivalent to the step from a Master's to a PhD. The meaning of that step is qualitative, not quantitative.
    </p>
    <p>
      Despite the challenges, we must find a reasonable way to cast ordinal values numerically for many ML algorithms. Ordinal-to-numeric mapping allows models to recognize ordering, but we must avoid letting the model misinterpret the numbers as proportional differences. Here are some safe strategies.
    </p>
    <p>
      <term>How to Map Ordinals Safely:</term>
    </p>
    <ol>
      <li>
        <p>
            **Integer Encoding (Simple Mapping)**
            Use integers to represent order, but be aware they are order markers, not measures of a constant difference.
            Example:
            <program language="python" line-numbers="yes">
                <code>
                education_order = {"High School": 1, "Bachelor's": 2, "Master's": 3, "PhD": 4}
                </code>
            </program>
        This mapping works well for tree-based models (e.g., Random Forest, XGBoost) because they split data based on order, not arithmetic differences.
        </p>
      </li>
      <li>
        <p>
          **Custom Binning or Grouping**
          For a wide range of ordinal categories, it can be useful to group them into fewer, more meaningful bins before mapping. This simplifies the data while retaining the core ordering information.
        </p>
      </li>
      <li>
        <p>
          **Use of Embeddings (for Deep Learning)**
          In deep learning, you can treat ordinal categories like tokens and learn their position in a multidimensional space. This method captures the ordering without assuming equal numeric gaps. The model learns a vector representation for each category that places it in a meaningful relative position to the others.
        </p>
      </li>
      <li>
        <p>
          **Do Not One-Hot Encode Ordinal Data**
          One-hot encoding removes the crucial order information entirely. While technically a valid transformation, it should only be used if the "order" of the categories is not meaningful to your analysis.
        </p>
      </li>
    </ol>
  </subsection>
  
  <subsection xml:id="subsec-Numerical-Data">
    <title>Numerical Data</title>
    <p>
      <term>Numerical Data</term> represents quantities that can be measured and compared numerically. Numerical variables can be further classified into two types:
    </p>
    <ul>
      <li>
        <p>
          <term>Discrete</term>: Values are countable items, often integers.
          Example: The number of rooms in a house (e.g., 3, 4, 5). You can't have 3.5 rooms.
        </p>
      </li>
      <li>
        <p>
          <term>Continuous</term>: Values are measurable quantities with potentially infinite precision.
          Example: Height, weight, temperature, or price of a product. A person's height could be 175.5 cm or 175.52 cm.
        </p>
      </li>
    </ul>
    <p>
      In most algorithms, every variable needs to be cast into some numerical representation for the algorithm to perform calculations.
    </p>
  </subsection>
  
  <subsection xml:id="subsec-data-type-summary">
    <title>Data Type Summary</title>
    <p>
      This table provides a quick reference for the key characteristics of each data type.
    </p>

    <table xml:id="table-data-type-comparison">
        <title>Comparison of Data Types</title>
        <p>This table summarizes the properties and common encoding methods for categorical, ordinal, and numerical data.</p>
        <tabular>
            <row>
                <cell></cell>
                <cell halign="center"></cell>
                <cell halign="center">Meaningful</cell>
                <cell halign="center">Common</cell>
                <cell halign="center"></cell>
            </row>
            <row bottom="minor">
                <cell></cell>
                <cell halign="center">Order</cell>
                <cell halign="center">Difference</cell>
                <cell halign="center">Encoding Method</cell>
                <cell halign="center">Examples</cell>
            </row>
            <row>
                <cell header="yes">Categorical</cell>
                <cell>No</cell>
                <cell>No</cell>
                <cell>One-Hot Encoding</cell>
                <cell>Colors, Genders, City Names</cell>
            </row>
            <row>
                <cell header="yes">Ordinal</cell>
                <cell>Yes</cell>
                <cell>No</cell>
                <cell>Integer Encoding</cell>
                <cell>Ratings (Low, Medium, High), T-shirt Sizes</cell>
            </row>
            <row>
                <cell header="yes">Numerical</cell>
                <cell>Yes</cell>
                <cell>Yes</cell>
                <cell>None</cell>
                <cell>Height, Weight, Temperature</cell>
            </row>
            <row>
                <cell header="yes"></cell>
                <cell></cell>
                <cell></cell>
                <cell>(Normalization/Scaling)</cell>
                <cell></cell>
            </row>
        </tabular>
    </table>

  </subsection>
</section>